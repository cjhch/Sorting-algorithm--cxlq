def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]  # 取出未排序部分的第一个元素
        j = i - 1
        # 将 key 插入到已排序部分的正确位置
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]  # 向后移动元素
            j -= 1
        arr[j + 1] = key  # 插入 key
    return arr

# 示例
arr = [5, 2, 4, 6, 1, 3]
sorted_arr = insertion_sort(arr)
print(sorted_arr)  # 输出: [1, 2, 3, 4, 5, 6]
#


#
算法网页及动画演示 https://www.runoob.com/w3cnote/insertion-sort.html
插入排序（Insertion Sort）是一种简单直观的排序算法，它的工作原理类似于整理扑克牌。

插入排序通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。
1. 算法步骤
初始化：将列表分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，未排序部分包含剩余元素。

选择元素：从未排序部分中取出第一个元素。

插入到已排序部分：将该元素与已排序部分的元素从后向前依次比较，找到合适的位置插入。

重复步骤：重复上述步骤，直到未排序部分为空，列表完全有序。
时间复杂度
最坏情况：O(n²)，当列表是逆序时，每次插入都需要移动所有已排序元素。

最好情况：O(n)，当列表已经有序时，只需遍历一次列表。

平均情况：O(n²)。

空间复杂度
O(1)，插入排序是原地排序算法，不需要额外的存储空间。

优缺点
优点：

实现简单，代码易于理解。

对小规模数据或基本有序的数据效率较高。

原地排序，不需要额外的存储空间。

稳定排序算法（相同元素的相对顺序不会改变）。

缺点：

时间复杂度较高，不适合大规模数据集。

适用场景
数据量较小或基本有序的场景。

需要稳定排序算法的场景。

作为更复杂排序算法（如快速排序、归并排序）的辅助算法
#
