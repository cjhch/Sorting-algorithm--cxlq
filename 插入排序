def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]  # 取出未排序部分的第一个元素
        j = i - 1
        # 将 key 插入到已排序部分的正确位置
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]  # 向后移动元素
            j -= 1
        arr[j + 1] = key  # 插入 key
    return arr

# 示例
arr = [5, 2, 4, 6, 1, 3]
sorted_arr = insertion_sort(arr)
print(sorted_arr)  # 输出: [1, 2, 3, 4, 5, 6]
#
1. 算法步骤
初始化：将列表分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，未排序部分包含剩余元素。

选择元素：从未排序部分中取出第一个元素。

插入到已排序部分：将该元素与已排序部分的元素从后向前依次比较，找到合适的位置插入。

重复步骤：重复上述步骤，直到未排序部分为空，列表完全有序。
时间复杂度
最坏情况：O(n²)，当列表是逆序时，每次插入都需要移动所有已排序元素。

最好情况：O(n)，当列表已经有序时，只需遍历一次列表。

平均情况：O(n²)。

空间复杂度
O(1)，插入排序是原地排序算法，不需要额外的存储空间。

优缺点
优点：

实现简单，代码易于理解。

对小规模数据或基本有序的数据效率较高。

原地排序，不需要额外的存储空间。

稳定排序算法（相同元素的相对顺序不会改变）。

缺点：

时间复杂度较高，不适合大规模数据集。

适用场景
数据量较小或基本有序的场景。

需要稳定排序算法的场景。

作为更复杂排序算法（如快速排序、归并排序）的辅助算法
#
