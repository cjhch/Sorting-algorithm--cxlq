堆排序
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
算法流程
1. 输入数组并建立大顶堆。完成后，最大元素位于堆顶。
2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。
3. 从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。
4. 循环执行第 2. 步和第 3. 步。循环 n -1 轮后，即可完成数组排序。

1. 构建最大堆：
  ○ 初始列表：[4, 10, 3, 5, 1]。
  ○ 从最后一个非叶子节点开始，逐步调整堆：
    ■ 调整节点 5：[4, 10, 3, 5, 1]（无需调整）。
    ■ 调整节点 10：[4, 10, 3, 5, 1]（无需调整）。
    ■ 调整节点 4：[10, 5, 3, 4, 1]。
  ○ 最终最大堆：[10, 5, 3, 4, 1]。
2. 交换堆顶元素：
  ○ 将堆顶元素 10 与最后一个元素 1 交换，列表变为 [1, 5, 3, 4, 10]。
  ○ 堆的大小减 1，已排序部分为 [10]。
3. 调整堆：
  ○ 对新的堆顶元素 1 进行下沉操作：
    ■ 比较 1 和其子节点 5、3，将 1 与 5 交换。
    ■ 列表变为 [5, 1, 3, 4, 10]。
    ■ 继续比较 1 和其子节点 4，将 1 与 4 交换。
    ■ 列表变为 [5, 4, 3, 1, 10]。
  ○ 调整后的堆：[5, 4, 3, 1]。
4. 重复步骤：
  ○ 将堆顶元素 5 与最后一个元素 1 交换，列表变为 [1, 4, 3, 5, 10]。
  ○ 堆的大小减 1，已排序部分为 [5, 10]。
  ○ 对新的堆顶元素 1 进行下沉操作：
    ■ 比较 1 和其子节点 4、3，将 1 与 4 交换。
    ■ 列表变为 [4, 1, 3, 5, 10]。
  ○ 调整后的堆：[4, 1, 3]。
5. 继续重复：
  ○ 将堆顶元素 4 与最后一个元素 3 交换，列表变为 [3, 1, 4, 5, 10]。
  ○ 堆的大小减 1，已排序部分为 [4, 5, 10]。
  ○ 对新的堆顶元素 3 进行下沉操作：
    ■ 比较 3 和其子节点 1，无需交换。
  ○ 调整后的堆：[3, 1]。
6. 最终步骤：
  ○ 将堆顶元素 3 与最后一个元素 1 交换，列表变为 [1, 3, 4, 5, 10]。
  ○ 堆的大小减 1，已排序部分为 [3, 4, 5, 10]。
  ○ 堆的大小为 1，排序完成。


void siftDown(int nums[], int n, int i) {
    while (1) {
        // 判断节点 i, l, r 中值最大的节点，记为 ma
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int ma = i;
        if (l < n && nums[l] > nums[ma])
            ma = l;
        if (r < n && nums[r] > nums[ma])
            ma = r;
        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出
        if (ma == i) {
            break;
        }
        // 交换两节点
        int temp = nums[i];
        nums[i] = nums[ma];
        nums[ma] = temp;
        // 循环向下堆化
        i = ma;
    }
}

/* 堆排序 */
void heapSort(int nums[], int n) {
    // 建堆操作：堆化除叶节点以外的其他所有节点
    for (int i = n / 2 - 1; i >= 0; --i) {
        siftDown(nums, n, i);
    }
    // 从堆中提取最大元素，循环 n-1 轮
    for (int i = n - 1; i > 0; --i) {
        // 交换根节点与最右叶节点（交换首元素与尾元素）
        int tmp = nums[0];
        nums[0] = nums[i];
        nums[i] = tmp;
        // 以根节点为起点，从顶至底进行堆化
        siftDown(nums, i, 0);
    }
}
● 时间复杂度为 O(nlog⁡n)、非自适应排序：建堆操作使用 O(n) 时间。从堆中提取最大元素的时间复杂度为 O(log⁡n) ，共循环 n−1 轮。
● 空间复杂度为 O(1)、原地排序：几个指针变量使用 O(1) 空间。元素交换和堆化操作都是在原数组上进行的。
