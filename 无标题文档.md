<h1 id="im0ve">排序</h1>
//桶排序，堆排序，快速排序，计数排序

<h2 id="pkCQO">快速排序</h2>
<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">快速排序（Quick Sort）是由东尼·霍尔所发展的一种排序算法,是一种高效的排序算法，基于分治法（Divide and Conquer）的思想。它的核心是通过选择一个基准元素（pivot），将列表分为两部分：一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序。也就是“哨兵划分”。</font>

<h3 id="hA0Fp"><font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">算法步骤：</font></h3>
1. **<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">选择基准元素</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">：从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素。</font>
2. **<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">分区</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">：将列表重新排列，使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧。基准元素的位置在分区完成后确定。</font>
3. **<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">递归排序</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">：对基准元素左侧和右侧的子列表分别递归地进行快速排序。</font>
4. **<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">合并</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">：由于分区操作是原地进行的，递归结束后整个列表已经有序。</font>

<h3 id="Q3aQp"><font style="color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);">快排流程如下：</font></h3>
![](https://cdn.nlark.com/yuque/0/2025/png/53947550/1741955406681-0b2af387-1c75-43c1-b283-8d43b0ea796d.png)

<h3 id="qkhYK">动图演示：</h3>
![](https://cdn.nlark.com/yuque/0/2025/gif/53947550/1741956931043-6ccdcc06-57e2-49e4-97f1-77ab5da819d5.gif)

<h3 id="WTSfj">主要代码：</h3>
```plain
int partition(int arr[], int low, int high) {
    // 选择最后一个元素作为基准值
    int pivot = arr[high];
    // 初始化小于基准值的元素的边界
    int i = low - 1;

    // 遍历数组，将小于基准值的元素交换到左边
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    // 将基准值放到正确的位置
    swap(arr[i + 1], arr[high]);
    // 返回基准值的最终位置
    return i + 1;
}

// 快速排序函数
// 参数 arr 为待排序的数组，low 为数组的起始索引，high 为数组的结束索引
void Quick_Sort(int arr[], int low, int high) {
    // 当起始索引小于结束索引时，说明数组还可以继续排序
    if (low < high) {
        // 进行分区操作，得到基准值的最终位置
        int pi = partition(arr, low, high);

        // 递归排序基准值左边的子数组
        Quick_Sort(arr, low, pi - 1);
        // 递归排序基准值右边的子数组
        Quick_Sort(arr, pi + 1, high);
    }
}

```

<h3 id="Kxszc">时间复杂度</h3>
● 分解：每次将列表分成两半，需要 O(log n) 层递归。

● 合并：每层递归需要 O(n) 的时间来合并子列表。

● 总时间复杂度：O(n log n)。

在最差情况下，每轮哨兵划分操作都将长度为 n 的数组划分为长度为 0 和 n−1 的两个子数组，此时递归层数达到 n ，每层中的循环数为 n ，总体使用 O($ n^2
 $) 时间。

<h3 id="qwJ84">空间复杂度</h3>
● O(n)，归并排序需要额外的空间来存储临时列表。

<h3 id="qSvTs">优缺点</h3>
● 优点：

  ○ 时间复杂度稳定为 O(n log n)，适合大规模数据。

  ○ 稳定排序算法（相同元素的相对顺序不会改变）。

  ○ 适合外部排序（如对磁盘文件进行排序）。

● 缺点：

  ○ 需要额外的存储空间，空间复杂度为 O(n)。

  ○ 对于小规模数据，性能可能不如插入排序等简单算法

注：还有二种优化 

+ [基准数优化](https://www.hello-algo.com/chapter_sorting/quick_sort/#1154)
+ [尾递归优化](https://www.hello-algo.com/chapter_sorting/quick_sort/#1155)

