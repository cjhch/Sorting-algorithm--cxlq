桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。。桶排序的核心思想是将数据分到有限数量的桶中，每个桶再分别排序（可以使用其他排序算法或递归地使用桶排序）。
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：
1. 在额外空间充足的情况下，尽量增大桶的数量
2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中
同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
算法流程
1. 初始化 k 个桶，将 n 个元素分配到 k 个桶中。
2. 对每个桶分别执行排序（这里采用编程语言的内置排序函数）。
3. 按照桶从小到大的顺序合并结果。

1. 什么时候最快
当输入的数据可以均匀的分配到每一个桶中。
2. 什么时候最慢
当输入的数据被分配到了同一个桶中。

假设有一个待排序的列表 [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]，桶排序的过程如下：
1. 初始化桶：
  ○ 假设数据范围是 [0, 1)，创建 10 个桶，每个桶的范围为 0.1。
  ○ 桶 0：[0.0, 0.1)
  ○ 桶 1：[0.1, 0.2)
  ○ ...
  ○ 桶 9：[0.9, 1.0)
2. 分配元素：
  ○ 遍历列表，将元素分配到对应的桶中：
    ■ 0.42 → 桶 4
    ■ 0.32 → 桶 3
    ■ 0.33 → 桶 3
    ■ 0.52 → 桶 5
    ■ 0.37 → 桶 3
    ■ 0.47 → 桶 4
    ■ 0.51 → 桶 5
  ○ 分配后的桶：
    ■ 桶 3：[0.32, 0.33, 0.37]
    ■ 桶 4：[0.42, 0.47]
    ■ 桶 5：[0.52, 0.51]
3. 排序每个桶：
  ○ 对每个桶中的元素进行排序：
    ■ 桶 3：[0.32, 0.33, 0.37]（已经有序）。
    ■ 桶 4：[0.42, 0.47]（已经有序）。
    ■ 桶 5：[0.51, 0.52]（排序后）。
4. 合并桶：
  ○ 按顺序合并所有桶中的元素：
    ■ 桶 3：[0.32, 0.33, 0.37]
    ■ 桶 4：[0.42, 0.47]
    ■ 桶 5：[0.51, 0.52]
  ○ 合并后的列表：[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]。

void bucketSort(float nums[], int n) {
    int k = n / 2;                                 // 初始化 k = n/2 个桶
    int *sizes = malloc(k * sizeof(int));          // 记录每个桶的大小
    float **buckets = malloc(k * sizeof(float *)); // 动态数组的数组（桶）
    // 为每个桶预分配足够的空间
    for (int i = 0; i < k; ++i) {
        buckets[i] = (float *)malloc(n * sizeof(float));
        sizes[i] = 0;
    }
    // 1. 将数组元素分配到各个桶中
    for (int i = 0; i < n; ++i) {
        int idx = (int)(nums[i] * k);
        buckets[idx][sizes[idx]++] = nums[i];
    }
    // 2. 对各个桶执行排序
    for (int i = 0; i < k; ++i) {
        qsort(buckets[i], sizes[i], sizeof(float), compare);
    }
    // 3. 合并排序后的桶
    int idx = 0;
    for (int i = 0; i < k; ++i) {
        for (int j = 0; j < sizes[i]; ++j) {
            nums[idx++] = buckets[i][j];
        }
        // 释放内存
        free(buckets[i]);
    }
}

● 时间复杂度为 O(n+k) ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\frac {n}{k}$。假设排序单个桶使用 O($\frac{n}{k}$log⁡$\frac{n}{k}$) 时间，则排序所有桶使用 O(nlog⁡$\frac {n}{k}$) 时间。当桶数量 k 比较大时，时间复杂度则趋向于 O(n) 。合并结果时需要遍历所有桶和元素，花费 O(n+k) 时间。在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 O($n^2$) 时间。
● 空间复杂度为 O(n+k)、非原地排序：需要借助 k 个桶和总共 n 个元素的额外空间。
如何实现平均分配¶
桶排序的时间复杂度理论上可以达到 O(n) ，关键在于将元素均匀分配到各个桶中，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等。
如果我们提前知道商品价格的概率分布，则可以根据数据概率分布设置每个桶的价格分界线。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。
