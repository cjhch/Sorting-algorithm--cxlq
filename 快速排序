
快速排序
快速排序（Quick Sort）是由东尼·霍尔所发展的一种排序算法,是一种高效的排序算法，基于分治法（Divide and Conquer）的思想。它的核心是通过选择一个基准元素（pivot），将列表分为两部分：一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序。也就是“哨兵划分”。
算法步骤：
1. 选择基准元素：从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素。
2. 分区：将列表重新排列，使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧。基准元素的位置在分区完成后确定。
3. 递归排序：对基准元素左侧和右侧的子列表分别递归地进行快速排序。
4. 合并：由于分区操作是原地进行的，递归结束后整个列表已经有序。
主要代码：
int partition(int arr[], int low, int high) {Int partition(Int arr[], Int low, Int high) {
    // 选择最后一个元素作为基准值
    int pivot = arr[high];   Int pivot = arr[high]；
    // 初始化小于基准值的元素的边界
    int i = low - 1;Int I = low - 1；

    // 遍历数组，将小于基准值的元素交换到左边
    for (int j = low; j <= high - 1; j++) {For (int j = low；J <= high - 1；J) {
        if (arr[j] < pivot) {如果（arr[j] < pivot） {
            i++;   我;
            swap(arr[i], arr[j]);   交换(arr[我],arr [j]);
        }
    }
    // 将基准值放到正确的位置
    swap(arr[i + 1], arr[high]);交换（arr[i 1], arr[high]）；
    // 返回基准值的最终位置
    return i + 1;   返回I 1；
}

// 快速排序函数
// 参数 arr 为待排序的数组，low 为数组的起始索引，high 为数组的结束索引
void Quick_Sort(int arr[], int low, int high) {
    // 当起始索引小于结束索引时，说明数组还可以继续排序
    if (low < high) {If (low < high) {
        // 进行分区操作，得到基准值的最终位置
        int pi = partition(arr, low, high);Int PI = partition(arr, low, high)；

        // 递归排序基准值左边的子数组
        Quick_Sort(arr, low, pi - 1);Quick_Sort(arr, low, pi - 1)；
        // 递归排序基准值右边的子数组
        Quick_Sort(arr, pi + 1, high);快速排序（arr, pi 1, high）；
    }
}
时间复杂度
● 分解：每次将列表分成两半，需要 O(log n) 层递归。
● 合并：每层递归需要 O(n) 的时间来合并子列表。
● 总时间复杂度：O(n log n)。
在最差情况下，每轮哨兵划分操作都将长度为 n 的数组划分为长度为 0 和 n−1 的两个子数组，此时递归层数达到 n ，每层中的循环数为 n ，总体使用 O($n^2$) 时间。
空间复杂度
● O(n)，归并排序需要额外的空间来存储临时列表。
优缺点
● 优点：
  ○ 时间复杂度稳定为 O(n log n)，适合大规模数据。
  ○ 稳定排序算法（相同元素的相对顺序不会改变）。
  ○ 适合外部排序（如对磁盘文件进行排序）。
● 缺点：
  ○ 需要额外的存储空间，空间复杂度为 O(n)。
  ○ 对于小规模数据，性能可能不如插入排序等简单算法

