def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # 初始增量
    while gap > 0:
        # 对每个子列表进行插入排序
        for i in range(gap, n):
            temp = arr[i]  # 当前待插入元素
            j = i
            # 在子列表中找到合适的位置插入
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # 缩小增量
    return arr

# 示例
arr = [8, 3, 1, 2, 7, 5, 6, 4]
sorted_arr = shell_sort(arr)
print(sorted_arr)  # 输出: [1, 2, 3, 4, 5, 6, 7, 8]
#

#
算法流程及动画演示https://www.runoob.com/w3cnote/shell-sort.html
1.4 希尔排序
分类 算法
希尔排序（Shell Sort）是插入排序的一种改进版本，也称为缩小增量排序。它通过将待排序的列表分成若干子列表，对每个子列表进行插入排序，逐步缩小子列表的间隔，最终完成整

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。
1. 算法步骤
选择增量序列：选择一个增量序列（gap sequence），用于将列表分成若干子列表。常见的增量序列有希尔增量（n/2, n/4, ..., 1）等。

分组插入排序：按照增量序列将列表分成若干子列表，对每个子列表进行插入排序。

缩小增量：逐步缩小增量，重复上述分组和排序过程，直到增量为 1。

最终排序：当增量为 1 时，对整个列表进行一次插入排序，完成排序。
时间复杂度
希尔排序的时间复杂度取决于增量序列的选择：

最坏情况：O(n²)，当增量序列选择不当时。

最好情况：O(n log n)，当增量序列选择合适时。

平均情况：O(n log n) 到 O(n²) 之间。

常见的增量序列：

希尔增量：n/2, n/4, ..., 1，时间复杂度为 O(n²)。

Hibbard 增量：1, 3, 7, 15, ..., 2^k - 1，时间复杂度为 O(n^(3/2))。

Sedgewick 增量：1, 5, 19, 41, 109, ...，时间复杂度为 O(n^(4/3))。

空间复杂度
O(1)，希尔排序是原地排序算法，不需要额外的存储空间。

优缺点
优点：

相对于简单插入排序，效率更高。

原地排序，不需要额外的存储空间。

适用于中等规模的数据集。

缺点：

时间复杂度依赖于增量序列的选择。

不稳定排序算法（可能改变相同元素的相对顺序）。

适用场景
中等规模的数据集。

对性能要求不高但需要比简单插入排序更高效的场景。

作为更复杂排序算法的预处理步骤。
#
