def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # 初始增量
    while gap > 0:
        # 对每个子列表进行插入排序
        for i in range(gap, n):
            temp = arr[i]  # 当前待插入元素
            j = i
            # 在子列表中找到合适的位置插入
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # 缩小增量
    return arr

# 示例
arr = [8, 3, 1, 2, 7, 5, 6, 4]
sorted_arr = shell_sort(arr)
print(sorted_arr)  # 输出: [1, 2, 3, 4, 5, 6, 7, 8]
#

#
算法网页及动画演示 https://www.runoob.com/w3cnote/insertion-sort.html
插入排序（Insertion Sort）是一种简单直观的排序算法，它的工作原理类似于整理扑克牌。

插入排序通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。
1. 算法步骤
选择增量序列：选择一个增量序列（gap sequence），用于将列表分成若干子列表。常见的增量序列有希尔增量（n/2, n/4, ..., 1）等。

分组插入排序：按照增量序列将列表分成若干子列表，对每个子列表进行插入排序。

缩小增量：逐步缩小增量，重复上述分组和排序过程，直到增量为 1。

最终排序：当增量为 1 时，对整个列表进行一次插入排序，完成排序。
时间复杂度
希尔排序的时间复杂度取决于增量序列的选择：

最坏情况：O(n²)，当增量序列选择不当时。

最好情况：O(n log n)，当增量序列选择合适时。

平均情况：O(n log n) 到 O(n²) 之间。

常见的增量序列：

希尔增量：n/2, n/4, ..., 1，时间复杂度为 O(n²)。

Hibbard 增量：1, 3, 7, 15, ..., 2^k - 1，时间复杂度为 O(n^(3/2))。

Sedgewick 增量：1, 5, 19, 41, 109, ...，时间复杂度为 O(n^(4/3))。

空间复杂度
O(1)，希尔排序是原地排序算法，不需要额外的存储空间。

优缺点
优点：

相对于简单插入排序，效率更高。

原地排序，不需要额外的存储空间。

适用于中等规模的数据集。

缺点：

时间复杂度依赖于增量序列的选择。

不稳定排序算法（可能改变相同元素的相对顺序）。

适用场景
中等规模的数据集。

对性能要求不高但需要比简单插入排序更高效的场景。

作为更复杂排序算法的预处理步骤。
#
